<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ボードゲーム箱ジェネレーター</title>
  <style>
    body { font-family: sans-serif; text-align: center; background: #f5f5f5; }
    input, select, button { margin: 0.5em; }
    canvas { display: block; margin: 1em auto; border: 1px solid #ccc; }
    label { display: block; }
  </style>
</head>
<body>
  <h1>ボードゲーム箱ジェネレーター</h1>
  <div>
    <label>正面画像: <input type="file" id="front"></label>
    <label>裏面画像: <input type="file" id="back"></label>
    <label>右側面画像: <input type="file" id="right"></label>
    <label>左側面画像: <input type="file" id="left"></label>
    <label>上面画像: <input type="file" id="top"></label>
    <label>底面画像: <input type="file" id="bottom"></label>
    <label>背景画像: <input type="file" id="bg"></label>
    <label>視点: 
      <select id="view">
        <option value="斜め上">斜め上</option>
        <option value="正面">正面</option>
        <option value="横">横</option>
      </select>
    </label>
    <label><input type="checkbox" id="shadowToggle" checked> 落ち影を表示</label>
    <button id="download">画像を保存</button>
  </div>
  <div id="canvas-container"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
  <script>
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ preserveDrawingBuffer: true, antialias: true });
    const renderSize = 1000;
    renderer.setSize(renderSize, renderSize);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xaaaaaa, 1.2);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 50;
    scene.add(directionalLight);

    const groundGeometry = new THREE.PlaneGeometry(100, 100);
    const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.75;
    ground.receiveShadow = true;
    scene.add(ground);

    const loader = new THREE.TextureLoader();
    let box;
    const textures = {};

    function createBox() {
      const required = ['front', 'back', 'right', 'left', 'top', 'bottom'];
      if (!required.every(k => textures[k])) return;

      if (box) scene.remove(box);

      const frontImage = textures.front.image;
      const rightImage = textures.right.image;

      const baseHeight = 1.5;
      const width = (frontImage.width / frontImage.height) * baseHeight;
      const height = baseHeight;
      const depth = (rightImage.width / rightImage.height) * baseHeight;

      const chamfer = 0.02;
      const geometry = new THREE.BoxGeometry(width - chamfer, height - chamfer, depth - chamfer);
      const materials = [
        new THREE.MeshLambertMaterial({ map: textures.right }),
        new THREE.MeshLambertMaterial({ map: textures.left }),
        new THREE.MeshLambertMaterial({ map: textures.top }),
        new THREE.MeshLambertMaterial({ map: textures.bottom }),
        new THREE.MeshLambertMaterial({ map: textures.front }),
        new THREE.MeshLambertMaterial({ map: textures.back })
      ];
      box = new THREE.Mesh(geometry, materials);
      box.castShadow = true;
      box.receiveShadow = false;
      scene.add(box);
    }

    function updateView() {
      const preset = document.getElementById('view').value;
      if (preset === '斜め上') camera.position.set(4, 3, 4);
      if (preset === '正面') camera.position.set(0, 2, 6);
      if (preset === '横') camera.position.set(6, 2, 0);
      camera.lookAt(0, 0, 0);
    }
    document.getElementById('view').addEventListener('change', updateView);

    document.getElementById('shadowToggle').addEventListener('change', (e) => {
      ground.visible = e.target.checked;
    });

    function handleUpload(id, key) {
      document.getElementById(id).addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        loader.load(url, (tex) => {
          tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
          textures[key] = tex;
          createBox();
        });
      });
    }

    ['front', 'back', 'right', 'left', 'top', 'bottom'].forEach(id => handleUpload(id, id));

    document.getElementById('bg').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      loader.load(url, (tex) => {
        scene.background = tex;
      });
    });

    document.getElementById('download').addEventListener('click', () => {
      const a = document.createElement('a');
      a.download = 'box.png';
      a.href = renderer.domElement.toDataURL('image/png');
      a.click();
    });

    updateView();

    function animate() {
      requestAnimationFrame(animate);
      if (box) box.rotation.y += 0.005;
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
